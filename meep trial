#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 20 16:19:20 2022

@author: go34660
"""
import meep as mp
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
#%%
"""
Current Tasks:
    What angle will give the strongest evanescent field?
    how am i supposed to detect the material? Which direction, beyond the source out the other side?
    try different materials, how do i put in different metals 
        look for papers with nanoparticle scattering
        how does the metal scattering actually work? is there a metal sheet?
    any specific method i should use to check for scattering?
    look how it can be applied to 3d or cylindrical polar coordinates?
    Any scattering theoretical stuff that I can apply?
        Evanescent scattering (mie? normal scatteirng?)
        What would change if the geometry of the nanoparticle is different? (circle, square, 2d, 3d, etc.)
        
"""
#%%
resolution = 50 #resolution per unit length
cell = mp.Vector3(24,20) #cell size
pml_layers = [mp.PML(1.0,direction=mp.Y)] #absorbing layers the waves go around (periodic boundary conditions)
theta = np.pi*50/180 #rotation angle

wavelength = 6.33 #10^-8
freq = 1/wavelength
eps = 2.31

k = mp.Vector3(0,-1,0).rotate(mp.Vector3(0,0,1),theta).scale(freq) * np.sqrt(eps) #k vector which decides the dicrection the wave travels in

def ampfunc(v3): #amplitude function used to for straight wave propagation
    return np.exp(2*np.pi*1j*(k*v3))

geometry = [mp.Block(mp.Vector3(mp.inf,4,mp.inf), #infinite block
                     #e1 = mp.Vector3(np.cos(theta),np.sin(theta)), #decides 2 axis which the block is rotated in
                     #e2 = mp.Vector3(-np.sin(theta),np.cos(theta)),
                     center = mp.Vector3(0,-6), #center should be high
                     material = mp.Medium(epsilon=eps)) #glass
                      ,
            mp.Cylinder(radius = 1,
                    height=0,
                    center = mp.Vector3(0,-1.5),
                    material = mp.Medium(epsilon=5))
                    ]
#%%
geometry2 = [mp.Block(mp.Vector3(mp.inf,4,mp.inf), #infinite block
                     #e1 = mp.Vector3(np.cos(theta),np.sin(theta)), #decides 2 axis which the block is rotated in
                     #e2 = mp.Vector3(-np.sin(theta),np.cos(theta)),
                     center = mp.Vector3(0,-6), #center should be high
                     material = mp.Medium(epsilon=eps)) #glass
             ]
#%%
sources = [mp.Source(mp.ContinuousSource(frequency=freq), #0.633 = 633nm?
                    component=mp.Ez, #in ez direction not really sure what polarization has on these stuff
                    size = mp.Vector3(24,0), #needs to encompass the whole cell for it to be straight
                    center=mp.Vector3(0,-7), #just put it right around the bottom limit
                    amp_func = ampfunc #amp function
                    )]

sim = mp.Simulation(cell_size=cell,
    	            boundary_layers=pml_layers,
                    geometry=geometry, #the geometry doesn't really work for now? Not really sure how
                    sources=sources, 
                    resolution=resolution,
                    k_point = k #need to define this
                    #default_material = mp.Medium(epsilon=1) 
                    )
#%%
sim2 = mp.Simulation(cell_size=cell,
    	            boundary_layers=pml_layers,
                    geometry=geometry2, #the geometry doesn't really work for now? Not really sure how
                    sources=sources, 
                    resolution=resolution,
                    k_point = k #need to define this
                    #default_material = mp.Medium(epsilon=1) 
                    )

# %%
# sim.init_sim()
# sim.solve_cw(tol=2e-6,maxiters=1000)
#%%
sim.run(mp.at_every(2, mp.output_png(mp.Ez, "-Zc dkbluered")),until=100) #saves jpeg files onto the working directory so be careful  
#%%
sim2.run(mp.at_every(2, mp.output_png(mp.Ez, "-Zc dkbluered")),until=100) #saves jpeg files onto the working directory so be careful  
#%%
ez_data = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Ez)
eps_data = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Dielectric)
eps_data_2 = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Dielectric)
ez_data_2 = sim2.get_array(center=mp.Vector3(), size=cell, component=mp.Ez)
#%%
"""
plot difference between the no circle and with circle
"""
plt.figure()
plt.imshow(eps_data_2.transpose(), interpolation='spline36', cmap='binary')
plt.imshow(np.real(ez_data_2 - ez_data).transpose(), interpolation='spline36', cmap='coolwarm', alpha=0.8)
#plt.axis('off')
plt.show()
#%%
"""
experimental setup
"""
eps_data = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Dielectric)
plt.figure()
plt.imshow(eps_data, interpolation='spline36', cmap='binary')
#plt.axis('off')
plt.show()

#%%
'''
Electric field map with circle
'''
ez_data = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Ez)
plt.figure()
plt.imshow(eps_data.transpose(), interpolation='spline36', cmap='binary')
plt.imshow(np.real(ez_data).transpose(), interpolation='spline36', cmap='coolwarm', alpha=0.8)
#plt.axis('off')
plt.show()

#%%
"""
simulation 1 only (validation of the evanescent waves and scattering)
with the ball only
"""
xs = np.linspace(-6,6,len(ez_data[0]))
plt.plot(xs,np.abs(ez_data[600])**2-np.abs(ez_data_2[600])**2,label = 'middle (difference)')
plt.plot(xs,np.abs(ez_data[300])**2-np.abs(ez_data_2[300])**2,label='edge')

plt.legend()
plt.xlim(-5,5)

