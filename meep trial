#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 20 16:19:20 2022

@author: go34660
"""
import meep as mp
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
import pandas as pd
#%%
"""
Current Tasks:
    increase size to accompany no field region
    What angle will give the strongest evanescent field?
    try different materials, how do i put in different metals 
        look for papers with nanoparticle scattering
        how does the metal scattering actually work? is there a metal sheet?
    any specific method i should use to check for scattering?
    look how it can be applied to 3d or cylindrical polar coordinates?
    Any scattering theoretical stuff that I can apply?
        Evanescent scattering (mie? normal scatteirng?)
        What would change if the geometry of the nanoparticle is different? (circle, square, 2d, 3d, etc.)
        
"""
#%%
resolution = 10 #resolution per unit length
ys = 800
cell = mp.Vector3(50,ys*2) #cell size
pml_layers = [mp.PML(1.0,direction=mp.Y)] #absorbing layers the waves go around (periodic boundary conditions)
theta = np.pi*43/180 #rotation angle

a = 1e-8
wavelength = 63.3 #10^-8
freq = 1/wavelength
eps = 2.31

k = mp.Vector3(0,-1,0).rotate(mp.Vector3(0,0,1),theta).scale(freq) * np.sqrt(eps) #k vector which decides the dicrection the wave travels in

def ampfunc(v3): #amplitude function used to for straight wave propagation
    return np.exp(2*np.pi*1j*(k*v3))

geometry = [mp.Block(mp.Vector3(mp.inf,300,mp.inf), #infinite block
                     #e1 = mp.Vector3(np.cos(theta),np.sin(theta)), #decides 2 axis which the block is rotated in
                     #e2 = mp.Vector3(-np.sin(theta),np.cos(theta)),
                     center = mp.Vector3(0,0), #center should be high
                     material = mp.Medium(epsilon=eps)) #glass
                      ,
            mp.Cylinder(radius = 2,
                    height=0,
                    center = mp.Vector3(0,25),
                    material = mp.Medium(epsilon=5))
                    ]
geometry2 = [mp.Block(mp.Vector3(mp.inf,300,mp.inf), #infinite block
                     #e1 = mp.Vector3(np.cos(theta),np.sin(theta)), #decides 2 axis which the block is rotated in
                     #e2 = mp.Vector3(-np.sin(theta),np.cos(theta)),
                     center = mp.Vector3(0,0), #center should be high
                     material = mp.Medium(epsilon=eps)) #glass
             ]
#%%
sources = [mp.Source(mp.ContinuousSource(frequency=freq), #0.633 = 633nm?
                    component=mp.Ez, #in ez direction not really sure what polarization has on these stuff
                    size = mp.Vector3(50,0), #needs to encompass the whole cell for it to be straight
                    center=mp.Vector3(0,0), #just put it right around the bottom limit
                    amp_func = ampfunc #amp function
                    )]
#%%
sim = mp.Simulation(cell_size=cell,
    	            boundary_layers=pml_layers,
                    geometry=geometry, #the geometry doesn't really work for now? Not really sure how
                    sources=sources, 
                    resolution=resolution,
                    k_point = k, #need to define this
                    default_material = mp.air 
                    )
#%%
sim2 = mp.Simulation(cell_size=cell,
    	            boundary_layers=pml_layers,
                    geometry=geometry2, #the geometry doesn't really work for now? Not really sure how
                    sources=sources, 
                    resolution=resolution,
                    k_point = k, #need to define this
                    default_material = mp.air 
                    )

# %%
# sim.init_sim()
# sim.solve_cw(tol=2e-6,maxiters=1000)
#%%
sim.run(mp.at_every(1, mp.output_png(mp.Ez, "-Zc dkbluered")),until=30) #saves jpeg files onto the working directory so be careful  
#%%
sim2.run(mp.at_every(1, mp.output_png(mp.Ez, "-Zc dkbluered")),until=200) #saves jpeg files onto the working directory so be careful  
#%%
ez_data = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Ez)
eps_data = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Dielectric)
#%%
eps_data_2 = sim2.get_array(center=mp.Vector3(), size=cell, component=mp.Dielectric)
ez_data_2 = sim2.get_array(center=mp.Vector3(), size=cell, component=mp.Ez)
#%%
"""
plot difference between the no circle and with circle
"""
plt.figure()
plt.imshow(eps_data_2.transpose(), interpolation='spline36', cmap='binary')
plt.imshow(np.real(ez_data_2).transpose(), interpolation='spline36', cmap='coolwarm', alpha=0.8)
#plt.axis('off')
plt.show()
#plt.ylim(50,600)
#%%
"""
experimental setup
"""
#eps_data = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Dielectric)
plt.figure()
plt.imshow(eps_data, interpolation='spline36', cmap='binary')
#plt.axis('off')
plt.show()

#%%
'''
Electric field map with circle
'''
#ez_data = sim.get_array(center=mp.Vector3(), size=cell, component=mp.Ez)
plt.figure()
plt.imshow(eps_data.transpose(), interpolation='spline36', cmap='binary')
plt.imshow(np.real(ez_data).transpose(), interpolation='spline36', cmap='coolwarm', alpha=0.8)
#plt.axis('off')
plt.show()

#%%
"""
simulation 1 only (validation of the evanescent waves and scattering)
with the ball only
"""
xs = np.linspace(-8,8,len(ez_data_2[0]))
#plt.plot(xs,np.abs(ez_data[150])**2)#,label = 'middle (difference)')
plt.plot(xs,np.real(ez_data_2[150])**2)#,label = 'middle (difference)')

#plt.plot(xs,np.abs(ez_data[0])**2,label='edge')

plt.legend()
#plt.xlim(-.15,0.15)
#%%
#angles = pd.DataFrame(ez_data_2[60],columns = ['forty_six'])
angles['forty_three'] = ez_data_2[60]
angles.to_csv('angle_data')
#%%
xs = np.linspace(0,ys*2,len(ez_data_2[0]))

plt.plot(xs,np.real(angles['forty_four'])**2,label = '40')
plt.plot(xs,np.real(angles['forty_four'])**2,label = '44')
plt.plot(xs,np.real(angles['forty_five'])**2,label = '45')
plt.plot(xs,np.real(angles['forty_six'])**2,label = '46')
plt.plot(xs,np.real(angles['forty_seven'])**2,label = '47')
plt.plot(xs,np.real(angles['forty_eight'])**2,label = '48')
plt.plot(xs,np.real(angles['forty_nine'])**2,label = '49')
plt.plot(xs,np.real(angles['fifty'])**2,label = '50')

#plt.xlim(4.9,24)
plt.legend()

#%%
plt.plot(xs,np.real(angles['forty_four'])**2,label = '40')




